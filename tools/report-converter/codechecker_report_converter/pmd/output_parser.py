# -------------------------------------------------------------------------
#
#  Part of the CodeChecker project, under the Apache License v2.0 with
#  LLVM Exceptions. See LICENSE for license information.
#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# -------------------------------------------------------------------------

import logging
import os
import xml.etree.ElementTree as ET

from ..output_parser import Message, Event, BaseParser

LOG = logging.getLogger('ReportConverter')


class PMDMessage(Message):
    """ Represents a message 
    This will be a diagnostic section in the plist which represents a report.
    """

    def __init__(self, path, line, column, message, checker,
                 events=None, notes=None, fixits=None):
        super(PMDMessage, self).__init__(path, line, column, message,
                                              checker, events, notes, fixits)

    def __eq__(self, other):
        return super(PMDMessage, self).__eq__(other) and \
            self.report_hash == other.report_hash

    def __str__(self):
        return '%s, report_hash=%s' % \
               (super(PMDMessage, self).__str__(), self.report_hash)


class PMDParser(BaseParser):
    """ Parser for PMD output. """

    def __init__(self):
        super(PMDParser, self).__init__()

    def parse_messages(self, analyzer_result):
        """ Parse the given analyzer result. """

        root = self.__parse_analyzer_result(analyzer_result)
        if root is None:
            return

        #report has a number of files
        #each file has a number of violations
        #https://github.com/pmd/pmd/blob/master/pmd-core/src/main/resources/report_2_0_0.xsd
        for bug in root.findall('file'):
            message = self.__parse_bug(bug)
            if message:
                for m in message:
                    self.messages.append(m)

        return self.messages

    def __parse_analyzer_result(self, analyzer_result):
        """ Parse the given analyzer result xml file.

        Returns the root element of the parsed tree or None if something goes
        wrong.
        """
        try:
            tree = ET.parse(analyzer_result)
            return tree.getroot()
        except OSError:
            LOG.error("Analyzer result does not exist: %s", analyzer_result)
        except ET.ParseError:
            LOG.error("Failed to parse the given analyzer result '%s'. Please "
                      "give a valid xml file with messages generated by "
                      "PMD.", analyzer_result)

    def __parse_bug(self, file):
        """ Parse the given violations and create messages from them """
        source_path = file.attrib.get('name')
        source_path = os.path.abspath(source_path)
        if not source_path:
            return None
        messages = []
        for bug in file.findall('violation'):
            checker_name = f"[{bug.attrib.get('ruleset')}]::{bug.attrib.get('rule')}"
            long_message = bug.tail

            line = bug.attrib.get('beginline')
            col = bug.attrib.get('begincolumn')

            messages.append(PMDMessage(source_path, int(line), col, long_message,
                                checker_name))
        return messages